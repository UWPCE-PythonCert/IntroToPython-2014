\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Intro to Python: Week 3]{Introduction  to Python\\ Sequences, List, Tuples}
\author{Christopher Barker}
\institute{UW Continuing Education}
\date{October 15, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Review/Questions}

% ---------------------------------------------
\begin{frame}{Review of Previous Class}

\begin{itemize}
  \item Recusive functions
  \item Truthiness
  \item Modules and name spaces
\end{itemize}

\vfill
{\large New sublime theme...}

\end{frame}

% ---------------------------------------------
\begin{frame}{Note about homework}

{\large About a 1/3 of you have been sending me homework to review.}

\vfill
{\large Which is jsut fine!}

\vfill
{\large But how do I know if you have learned the material?}

\vfill
{\large Final Project...}

\end{frame}


% ---------------------------------------------
\begin{frame}{Lightning Talks}

\vfill
{\LARGE Lightning talks today:}

\vfill
{\Large
Nate Flagg

\vfill
Duane Wright

\vfill
Jo-Anne Antoun 

\vfill
Josh Rakita

}
\vfill

\end{frame}


% ---------------------------------------------
\begin{frame}{Homework review}

  \vfill
  {\Large Homework Questions? }

  \vfill
  {\Large My Solution}

  \vfill
  {\Large Gary's Solution}

\end{frame}

% ************************************
\section {Sequences}

\begin{frame}[fragile]{Sequences}

{\Large Sequences are ordered collections of objects}

\vfill
{\Large They can be indexed, sliced, iterated over,...}

\vfill
{\Large They have a length:  \verb+len(sequence)+}

\vfill
{\Large Common sequences (Remember Duck Typing?):}

{\Large
\begin{itemize}
   \item strings
   \item tuples
   \item lists
\end{itemize}
}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large square brackets for indexing: \verb+[]+}

\vfill
{\Large Indexing starts at zero}

\begin{verbatim}
In [98]: s = "this is a string"

In [99]: s[0]
Out[99]: 't'

In [100]: s[5]
Out[100]: 'i'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Indexing}

{\Large Negative indexes count from the end}

\vfill
\begin{verbatim}
In [105]: s = "this is a string"

In [106]: s[-1]
Out[106]: 'g'

In [107]: s[-6]
Out[107]: 's'
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing: Pulling a range out of a sequence}

\begin{verbatim}
sequence[start:finish]  

indexes for which:

start <= i < finish
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}
\begin{verbatim}
In [121]: s = "a bunch of words"
In [122]: s[2]
Out[122]: 'b'

In [123]: s[6]
Out[123]: 'h'

In [124]: s[2:6]
Out[124]: 'bunc'

In [125]: s[2:7]
Out[125]: 'bunch'
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large the indexes point to the spaces between the items}

\vfill
\begin{verbatim}
   X   X   X   X   X   X   X   X
 |   |   |   |   |   |   |   | 
 0   1   2   3   4   5   6   7
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slices}

{\Large Slicing satisfies nifty properties:

\vfill
\begin{verbatim}
len( seq[a:b] ) == b - a

seq[a:b] + seq[b:c] == seq

\end{verbatim}

}

\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing returns a single element}

\begin{verbatim}
In [86]: l
Out[86]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [87]: type(l)
Out[87]: list

In [88]: l[3]
Out[88]: 3

In [89]: type( l[3] )
Out[89]: int
\end{verbatim}
\end{frame}

% ------------------------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Unless it's a string:}

\begin{verbatim}
In [75]: s = "a string"

In [76]: s[3]
Out[76]: 't'

In [77]: type(s[3])
Out[77]: str
\end{verbatim}

\vfill
There is no single character type

\end{frame}


%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Slicing returns a sequence:}

\begin{verbatim}
In [68]: l
Out[68]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [69]: l[2:4]
Out[69]: [2, 3]
\end{verbatim}

Even if it's one element long

\begin{verbatim}
In [70]: l[2:3]
Out[70]: [2]

In [71]: type(l[2:3])
Out[71]: list
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Slicing vs. Indexing}

{\Large Indexing out of range produces an error}
\vfill
\begin{verbatim}
In [129]: s = "a bunch of words"
In [130]: s[17]
----> 1 s[17]
IndexError: string index out of range
\end{verbatim}

\vfill
{\Large Slicing just gives you what's there}

\begin{verbatim}
In [131]: s[10:20]
Out[131]: ' words'

In [132]: s[20:30]
Out[132]: ''
\end{verbatim}
(demo)
\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{Multiplying and slicing}

{\Large from CodingBat: Warmup-1 -- front3}

\begin{verbatim}
def front3(str):
  if len(str) < 3:
    return str+str+str
  else:
    return str[:3]+str[:3]+str[:3]
\end{verbatim}

{\Large or}

\begin{verbatim}
def front3(str):
    return str[:3] * 3
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large from CodingBat: Warmup-1 -- \verb+missing_char+ }

\begin{verbatim}
def missing_char(str, n):
  front = str[0:n]
  l = len(str)-1
  back = str[n+1:l+1]
  return front + back
\end{verbatim}

\begin{verbatim}
def missing_char(str, n):
    return str[:n] + str[n+1:]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Slicing}

{\Large you can skip items, too}

\begin{verbatim}
In [289]: string = "a fairly long string"

In [290]: string[0:15]
Out[290]: 'a fairly long s'

In [291]: string[0:15:2]
Out[291]: 'afil ogs'

In [292]: string[0:15:3]
Out[292]: 'aallg'
\end{verbatim}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{LAB}
Write some functions that:
\begin{itemize}
  \item return a string with the first and last characters exchanged.
  \item return a string with every other character removed
  \item return a string with the first and last 4 characters removed, and every other char in between
  \item return a string reversed (just with slicing)
  \item return a string with the middle, then last, then first third in a new order
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large Nate Flag}

\vfill
{\large Duane Wright}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lists, Tuples...}

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List Literals}

\begin{verbatim}
>>> []
[]
>>> list()
[]
>>> [1, 2, 3]
[1, 2, 3]
>>> [1, 3.14, "abc"]
[1, 3.14, 'abc']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Lists}

 {\Large List ``type''}

 {\large \hspace{0.1in}(also constructor)}

\begin{verbatim}
>>> type(list)
<type 'type'>
>>> list( (1,2,3) )
[1, 2, 3]
>>> list( "a string" )
\end{verbatim}

\vfill
{\Large Takes any sequence, tries to turn it into a list}

\vfill
{\large like \verb|int()|, \verb|float()|, etc.}


\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Indexing}

 {\Large Indexing just like all sequences}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[2]
'ham'
>>> food[0]
'spam'
>>> food[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Mutability}

{\Large Lists are mutable}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food[1] = 'raspberries'
>>> food
['spam', 'raspberries', 'ham']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Elements}

{\Large Each element is a value, and can be in multiple lists and have multiple
names (or no name)}

\begin{verbatim}
  >>> name = 'Brian'
   >>> a = [1, 2, name]
   >>> b = [3, 4, name]
   >>> name
   'Brian'
   >>> a
   [1, 2, 'Brian']
   >>> b
   [3, 4, 'Brian']
   >>> a[2]
   'Brian'
   >>> b[2]
   'Brian'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\Large \verb| .append(), .insert()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.append('sushi')
>>> food
['spam', 'eggs', 'ham', 'sushi']
>>> food.insert(0, 'carrots')
>>> food
['carrots', 'spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb| .extend()|}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.extend(['fish', 'chips'])
>>> food
['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}

{\large could be any sequence:}

\begin{verbatim}
>>>  food
>>>  ['spam', 'eggs', 'ham']
>>>  silverware = ('fork', 'knife', 'spoon') # a tuple
>>>  food.extend(silverware)
>>>  food
>>>  ['spam', 'eggs', 'ham', 'fork', 'knife', 'spoon']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Methods}

{\large \verb|pop(), remove() |}

\begin{verbatim}
In [203]: food = ['spam', 'eggs', 'ham', 'toast']
In [204]: food.pop()
Out[204]: 'toast'
In [205]: food.pop(0)
Out[205]: 'spam'
In [206]: food
Out[206]: ['eggs', 'ham']
In [207]: food.remove('ham')
In [208]: food
Out[208]: ['eggs']
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Constructor}

{\large \verb|list()| accepts any sequence and returns a list of that sequence}
\begin{verbatim}
>>> word = 'Python '
>>> chars = []
>>> for char in word:
...   chars.append(char)
>>> chars
['P', 'y', 't', 'h', 'o', 'n', ' ']
>>> list(word)
['P', 'y', 't', 'h', 'o', 'n', ' ']
\end{verbatim}
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{String to List to String}

{\large If you need to change individual letters... you can do this,
but usually \verb|somestring.replace()| will be enough }

\begin{verbatim}
In [216]: name = 'Chris'
In [217]: lname = list(name)
In [218]: lname[0:2] = 'K'
In [219]: name = ''.join(lname)
In [220]: name
Out[220]: 'Kris'
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Building up strings in a list}

\begin{verbatim}
In [221]: msg = []

In [222]: msg.append('The first line of a message')

In [223]: msg.append('The second line of a message')

In [224]: msg.append('And one more line')

In [225]: print '\n'.join(msg)
The first line of a message
The second line of a message
And one more line
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Slicing makes a copy}

\begin{verbatim}
In [227]: food = ['spam', 'eggs', 'ham', 'sushi']

In [228]: some_food = food[1:3]

In [229]: some_food[1] = 'bacon'

In [230]: food
Out[230]: ['spam', 'eggs', 'ham', 'sushi']

In [231]: some_food
Out[231]: ['eggs', 'bacon']
\end{verbatim}

\end{frame}


% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\large Easy way to copy a whole list}

\begin{verbatim}
In [232]: food
Out[232]: ['spam', 'eggs', 'ham', 'sushi']

In [233]: food2 = food[:]

In [234]: food is food2
Out[234]: False

\end{verbatim}

{\Large but the copy is ``shallow''}: \
\url{http://docs.python.org/library/copy.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Slicing}

{\Large ``Shallow'' copy}

\begin{verbatim}
In [249]: food = ['spam', ['eggs', 'ham']]
In [251]: food_copy = food[:]
In [252]: food[1].pop()
Out[252]: 'ham'
In [253]: food
Out[253]: ['spam', ['eggs']]
In [256]: food.pop(0)
Out[256]: 'spam'
In [257]: food
Out[257]: [['eggs']]
In [258]: food_copy
Out[258]: ['spam', ['eggs']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Name Binding}

{\Large Assigning to a name does not copy:}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food_again = food
>>> food_copy = food[:]
>>> food.remove('sushi')
>>> food
['spam', 'eggs', 'ham']
>>> food_again
['spam', 'eggs', 'ham']
>>> food_copy
['spam', 'eggs', 'ham', 'sushi']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List Iterating}

{\Large Iterating over a list}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food:
...   print x
...
spam
eggs
ham
sushi
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Processing Lists}

{\Large A common pattern}

\begin{verbatim}
filtered = []
for x in somelist:
    if should_be_included(x):
        filtered.append(x)
del(somelist)  # maybe
\end{verbatim}

{\Large you don't want to be deleting items from the list while iterating...}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Mutating Lists}

{\Large if you're going to change the list, iterate over a copy for safety }

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> for x in food[:]:
   ...   # change the list somehow
   ...
\end{verbatim}

{\Large insidious bugs otherwise}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{operators vs methods}

{\large What's the difference?}

\begin{verbatim}
   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food = food + more
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']

   >>> food = ['spam', 'eggs', 'ham']
   >>> more = ['fish', 'chips']
   >>> food.extend(more)
   >>> food
   ['spam', 'eggs', 'ham', 'fish', 'chips']
\end{verbatim}
(the operator makes a new list...)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{in}

\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> 'eggs' in food
True
>>> 'chicken feet' in food
False
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{reverse()}


\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham']
>>> food.reverse()
>>> food
['ham', 'eggs', 'spam']
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{sort()}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> food.sort()
>>> food
['eggs', 'ham', 'spam', 'sushi']
\end{verbatim}

\vfill
{\Large note:}

\vfill
\begin{verbatim}
>>> food = ['spam', 'eggs', 'ham', 'sushi']
>>> result = food.sort()
>>> print result
None
\end{verbatim}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large How should this sort?}

\begin{verbatim}
>>> s
[[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
\end{verbatim}

\pause

\begin{verbatim}
>>> s.sort()
>>> s
[[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'c']]
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\large You can specify your own compare function:}

\begin{verbatim}
In [279]: s = [[2, 'a'], [1, 'b'], [1, 'c'], [1, 'a'], [2, 'c']]
In [281]: def comp(s1,s2):
   .....:     if s1[1] > s2[1]: return 1
   .....:     elif s1[1]<s2[1]: return -1
   .....:     else:
   .....:         if s1[0] > s2[0]: return 1
   .....:         elif s1[0] < s2[0]: return -1
   .....:     return 0
In [282]: s.sort(comp)
In [283]: s
Out[283]: [[1, 'a'], [2, 'a'], [1, 'b'], [1, 'c'], [2, 'c']]
\end{verbatim}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Sorting}

{\Large
Mixed types can be sorted.
}
\vfill
{\center \Large

``objects of different types always compare unequal, and are ordered
consistently but arbitrarily.''

}

\vfill
\url{http://docs.python.org/reference/expressions.html#not-in}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Searching}

{\Large Finding or Counting items}

\begin{verbatim}
In [288]: l = [3,1,7,5,4,3]

In [289]: l.index(5)
Out[289]: 3

In [290]: l.count(3)
Out[290]: 2
\end{verbatim}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{List Performance }

\begin{itemize}
  \item indexing is fast and constant time: O(1)
  \item x in s proportional to n: O(n)
  \item visiting all is proportional to n: O(n)
  \item operating on the end of list is fast and constant time: O(1) \\
     append(), pop()
  \item operating on the front (or middle) of the list depends on n: O(n)\\
     pop(0), insert(0, v) \\
     But, reversing is fast. Also, collections.deque
\end{itemize}

\url{ http://wiki.python.org/moin/TimeComplexity}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Lists vs. Tuples}

\vfill
{\Large List or Tuples}

\vfill
{\Large
If it needs to mutable: list

\vfill
If it needs to be immutable: tuple\\
}
\hspace{0.2in}{\large (dict key, safety when passing to a function) }

\vfill
{\Large Otherwise ... taste and convention}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

\vfill
{\LARGE Convention:}

\vfill
{\Large Lists are Collections (homogeneous):\\[0.1in]
-- contain values of the same type \\ 
-- simplifies iterating, sorting, etc
}

\vfill
{\Large tuples are mixed types:\\[0.1in]
-- Group multiple values into one logical thing
-- Kind of like simple C structs.
}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element?
  \item Small collection of values which make a single logical item?
  \item To document that these values won't change?
  \item Build it iteratively?
  \item Transform, filter, etc?
\end{itemize}
}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{List vs Tuple}

{\Large
\begin{itemize}
  \item Do the same operation to each element? {\bf list}
  \item Small collection of values which make a single logical item? {\bf tuple}
  \item To document that these values won't change? {\bf tuple}
  \item Build it iteratively? {\bf list}
  \item Transform, filter, etc? {\bf list}
\end{itemize}
}

\end{frame} 

\begin{frame}[fragile]{List Docs}

\vfill
{\Large The list docs:}

\vfill
\url{http://docs.python.org/library/stdtypes.html#mutable-sequence-types}

\vfill
(actually any mutable sequence....)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples don't NEED parentheses... }

\begin{verbatim}
In [161]: t = (1,2,3)
In [162]: t
Out[162]: (1, 2, 3)

In [163]: t = 1,2,3
In [164]: t
Out[164]: (1, 2, 3)

In [165]: type(t)
Out[165]: tuple
\end{verbatim}

\end{frame}

% ---------------------------------------------
\begin{frame}[fragile]{tuples and commas..}

{\Large  Tuples do need commas... }

\begin{verbatim}
In [156]: t = ( 3 )

In [157]: type(t)
Out[157]: int

In [158]: t = (3,)
In [159]: t
Out[159]: (3,)

In [160]: type(t)
Out[160]: tuple
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
{\LARGE List Lab}

\vfill
\verb|week-03/code/list_lab.rst|

\vfill

\end{frame}

%-------------------------------
\begin{frame}{Lightning Talk}

{\LARGE Lightning Talks:}

\vfill
{\large Jo-Anne Antoun}

\vfill
{\large Josh Rakita}

\end{frame}



\section{Looping}

%-------------------------------
\begin{frame}[fragile]{for loops}

{\Large looping through sequences

\begin{verbatim}
for x in sequence:
    do_something_with_x
\end{verbatim}
}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{for loops}

\begin{verbatim}
In [170]: for x in "a string":
   .....:         print x
   .....:     
a
 
s
t
r
i
n
g
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large looping a known number of times..}

\begin{verbatim}
In [171]: for i in range(5):
   .....:     print i
   .....:     
0
1
2
3
4
\end{verbatim}
(you don't need to do anything with i...
\end{frame}

%-------------------------------
\begin{frame}[fragile]{range}

{\Large \verb|range| defined similarly to indexing}

\begin{verbatim}
In [183]: range(4)
Out[183]: [0, 1, 2, 3]

In [184]: range(2,4)
Out[184]: [2, 3]

In [185]: range(2,10,2)
Out[185]: [2, 4, 6, 8]
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Python only loops through a sequence -- not like C, Javascript, etc...}
\begin{verbatim}
for(var i=0; i<arr.length; i++) {
    var value = arr[i];
    alert(i =") "+value);
}
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large Use range?}
\begin{verbatim}
In [193]: letters = "Python"

In [194]: for i in range(len(letters)):
   .....:     print letters[i]
   .....:     
P
y
t
h
o
n
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{indexing?}

{\Large More Pythonic -- for loops through sequences}
\begin{verbatim}
In [196]: for l in letters:
   .....:     print l
   .....:     
P
y
t
h
o
n
\end{verbatim}
\vfill
{\large Never index in normal cases}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{enumerate}

{\Large If you need an index -- \verb|enumerate|}
\begin{verbatim}
In [197]: for i, l in enumerate(letters):
   .....:     print i, l
   .....:     
0 P
1 y
2 t
3 h
4 o
5 n
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{multiple sequences -- zip}

{\Large If you need to loop though parallel sequences -- \verb|zip|}
\begin{verbatim}
In [200]: first_names = ['Fred', 'Mary', 'Jane']

In [201]: last_names = ['Baker', 'Jones', 'Miller']

In [203]: for first, last in zip(first_names, last_names):
   .....:     print first, last
   .....:     
Fred Baker
Mary Jones
Jane Miller
\end{verbatim}
\end{frame}

%-------------------------------
\begin{frame}[fragile]{xrange}

{\Large \verb|range| creates the whole list}

\vfill
{\Large \verb|xrange| is a generator -- creates it as it's needed --}

\vfill
{\Large a good idea for large numbers}

\begin{verbatim}
In [207]: for i in xrange(3):
   .....:     print i
0
1
2
\end{verbatim}
(Python 3 -- \verb|range == xrange|)
\end{frame}



%-------------------------------
\begin{frame}[fragile]{for}

{\Large \verb|for| does NOT create a name space:}

\begin{verbatim}
In [172]: x = 10

In [173]: for x in range(3):
   .....:     pass
   .....: 

In [174]: x
Out[174]: 2
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is for when you don't know how many loops you need}

\vfill
{\Large Continues to execute the body until condition is not \verb|True|}

\begin{verbatim}
while a_condition:
   some_code
   in_the_body
\end{verbatim}
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while}

{\Large \verb|while| is more general than \verb|for| -- 
you can always express for as while,
but not always vice-versa.}

\vfill

{\Large \verb|while| is more error-prone -- requires some care to terminate}

\vfill
{\Large  loop body must make progress, so condition can become \verb|False| }

\vfill
{\Large  potential error: infinite loops }
\end{frame}



%-------------------------------
\begin{frame}[fragile]{while vs. for}

\begin{verbatim}
letters = 'Python'
i=0
while i < len(letters):
    print letters[i]
    i += 1
\end{verbatim}
vs.
\begin{verbatim}
letters = 'Python'
for c in letters:
    print c
\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{while}

{\Large Shortcut: recall -- 0 or empty sequence is \verb|False| }

%\begin{verbatim}
%while x:    # terminates if x >= 0 on entry
%    ...     # do something with x
%    x -= 1  # make progress toward 0
%\end{verbatim}

\end{frame}


%-------------------------------
\begin{frame}[fragile]{break}

{\Large \verb|break| ends a loop early}

\begin{verbatim}
x = 0
while True:
    print x
    if x > 2:
        break
    x = x + 1
In [216]: run for_while.py
0
1
2
3
\end{verbatim}

\vfill
(This is a pretty common idiom)

\end{frame}

%-------------------------------
\begin{frame}[fragile]{break}

{\Large same way with a \verb|for| loop }

\begin{verbatim}
name = "Chris Barker"
for c in name:
    print c,
    if c == "B":
        break
print "I'm done"

C h r i s   B 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| skips to the start of the loop again}

\begin{verbatim}
print "continue in a for loop"
name = "Chris Barker"
for c in name:
    if c == "B":
        continue
    print c,
print "\nI'm done"

continue in a for loop
C h r i s   a r k e r 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{continue}

{\Large \verb|continue| works for a \verb|while| loop too.}

\begin{verbatim}
print "continue in a while loop"
x = 6
while x > 0:
    x = x-1
    if x%2:
        continue
    print x,
print "\nI'm done"

continue in a while loop
4 2 0 
I'm done
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{else again}

{\Large \verb|else| block run if the loop finished naturally -- no \verb|break|}

\begin{verbatim}
print "else in a for loop"
x = 5
for i in range(5):
    print i
    if i == x:
        break
else:
    print "else block run"

\end{verbatim}
\end{frame}

\section{Fun with Strings}

% ---------------------------------------------
\begin{frame}[fragile]{Strings}

{\Large A string literal creates a string type}

\begin{verbatim}
"this is a string"
\end{verbatim}

{\Large Can also use \verb|str()|}

\begin{verbatim}
In [256]: str(34)
Out[256]: '34'
\end{verbatim}
{\Large or "back ticks"}
\begin{verbatim}
In [258]: `34`
Out[258]: '34'
\end{verbatim}
(demo)
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
s.lower()
s.upper()
     ...
s.capitalize()
s.swapcase()
s.title()
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
x in s
s.startswith(x)
s.endswith(x)
...
s.index(x)
s.find(x)
s.rfind(x)
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The String Type}

{\Large Lots of nifty methods:}

\begin{verbatim}
s.split()
s.join(list)
...
s.splitlines()
\end{verbatim}

\url{http://docs.python.org/library/stdtypes.html#index-23}
\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Joining Strings}

{\Large The Join Method:}

\vfill
\begin{verbatim}
In [289]: t = ("some", "words","to","join")

In [290]: " ".join(t)
Out[290]: 'some words to join'

In [291]: ",".join(t)
Out[291]: 'some,words,to,join'

In [292]: "".join(t)
Out[292]: 'somewordstojoin'
\end{verbatim}

\vfill
(demo -- join)

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{The string module}

{\Large Lots of handy constants, etc.}
\begin{verbatim}
string.ascii_letters
string.ascii_lowercase 
string.ascii_uppercase  
string.letters
string.hexdigits 
string.whitespace
string.printable
string.digits
string.punctuation      
\end{verbatim}

\vfill
(and the string methods -- legacy)

\vfill
{\small \url{http://docs.python.org/2/library/string.html#module-string} }
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{String Literals}

{\Large Common Escape Sequences}
\vfill
\begin{verbatim}
\\  Backslash (\)   
\a  ASCII Bell (BEL)  
\b  ASCII Backspace (BS)  
\n  ASCII Linefeed (LF)   
\r  ASCII Carriage Return (CR)  
\t  ASCII Horizontal Tab (TAB)  
\ooo  Character with octal value ooo 
\xhh  Character with hex value hh
\end{verbatim}
(\url{http://docs.python.org/release/2.5.2/ref/strings.html})
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Raw Strings}

{\Large Escape Sequences Ignored}
\vfill
\begin{verbatim}
In [408]: print "this\nthat"
this
that
In [409]: print r"this\nthat"
this\nthat
\end{verbatim}

{\Large Gotcha:}
\begin{verbatim}
In [415]: r"\"
SyntaxError: EOL while scanning string literal
\end{verbatim}

\vfill
(handy for regex, windows paths...)
\end{frame} 



% ---------------------------------------------
\begin{frame}[fragile]{Character Values}

{\Large Characters in strings are stored as numeric values}

\vfill
{\large ``ASCII'' values: 1-127}

\vfill
{\large ``ANSI'' values: 1-255}


\vfill
{\large To get the value:}
\begin{verbatim}
In [109]: for i in 'Chris':
   .....:     print ord(i), 
67 104 114 105 115

In [110]: for i in (67,104,114,105,115):
   .....:     print chr(i),
C h r i s
\end{verbatim}

\vfill
(next week: unicode!)
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Building Strings}

{\Large Please don't do this:

\vfill
\begin{verbatim}
'Hello ' + name + '!'
\end{verbatim}
}
\vfill
(much)

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Building Strings}

{\Large Do this instead:

\vfill
\begin{verbatim}
'Hello %s!' % name
\end{verbatim}

\vfill
much faster and safer:

\vfill
easier to modify as code gets complicated
}

\vfill
\url{http://docs.python.org/library/stdtypes.html#string-formatting-operations}
\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{String Formatting}

{\Large The string format operator: \%}

\begin{verbatim}
In [261]: "an integer is: %i"%34
Out[261]: 'an integer is: 34'

In [262]: "a floating point is: %f"%34.5
Out[262]: 'a floating point is: 34.500000'

In [263]: "a string is: %s"%"anything"
Out[263]: 'a string is: anything'
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{String Formatting}

{\Large multiple arguments:}

\begin{verbatim}
In [264]: "the number %s is %i"%('five', 5)
Out[264]: 'the number five is 5'

In [266]: "the first 3 numbers are: %i, %i, %i"%(1,2,3)
Out[266]: 'the first 3 numbers are: 1, 2, 3'

\end{verbatim}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large Gotcha}

\begin{verbatim}
In [127]: "this is a string with %i formatting item"%1 
Out[127]: 'this is a string with 1 formatting item'

In [128]: "string with %i formatting %s: "%2, "items" 
TypeError: not enough arguments for format string

# Done right:
In [131]: "string with %i formatting %s"%(2, "items")
Out[131]: 'string with 2 formatting items'

In [132]: "string with %i formatting item"%(1,)
Out[132]: 'string with 1 formatting item' 
\end{verbatim}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large Named arguments}

\begin{verbatim}
'Hello %(name)s!'%{'name':'Joe'}
'Hello Joe!'

'Hello %(name)s, how are you, %(name)s!' %{'name':'Joe'}
'Hello Joe, how are you, Joe!'
\end{verbatim}
\vfill
{\Large That last bit is a dictionary (next week) }

\end{frame}

%-------------------------------
\begin{frame}[fragile]{String formatting}

{\Large The format operator works with string variables, too:}

\begin{verbatim}
In [45]: s = "%i / %i = %i"

In [46]: a, b = 12, 3

In [47]: s%(a, b, a/b)
Out[47]: '12 / 3 = 4'
\end{verbatim}
\vfill
So you can dynamically build a format string
\end{frame}

%-------------------------------
\begin{frame}[fragile]{Advanced Formatting}

{\Large The format method}

\begin{verbatim}
In [14]: 'Hello {0} {1}!'.format('Joe', 'Barnes')
Out[14]: 'Hello Joe Barnes!'

In [12]: 'Hello {name}!'.format(name='Joe')
Out[12]: 'Hello Joe!'
\end{verbatim}
\vfill
{\Large pick one (probably regular string formatting): \\
  -- get comfy with it }

\end{frame}


%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large Fun with strings}

\begin{itemize}
  \item Rewrite: \verb| the first 3 numbers are: %i, %i, %i"%(1,2,3)| \\
        for an arbitrary number of numbers...
  \item write a format string that will take:\\
        \verb|( 2, 123.4567, 10000)| \\
        and produce: \\
        \verb|'file_002 :   123.46, 1e+04'|
  \item Write a (really simple) mail merge program
  \item ROT13 -- see next slide
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}

\vfill
\Large￼ROT13 encryption

\vfill
Applying ROT13 to a piece of text merely requires examining its alphabetic
characters and replacing each one by the letter 13 places further along in
the alphabet, wrapping back to the beginning if necessary

\begin{itemize}
  \item Implement rot13 decoding 
  \item  decode this message: \\
     \hspace{0.5in} Zntargvp sebz bhgfvqr arne pbeare \\
     \hspace{0.5in} (from a geo-caching hint)
\end{itemize}

\end{frame}



%-------------------------------
\begin{frame}[fragile]{Homework}

{\Large Recommended Reading:}
\begin{itemize}
  \item Think Python: Chapt. 9 -- 14
  \item Dive Into Python: Chapt. 6
  \item String methods: \url{http://docs.python.org/library/stdtypes.html#string-methods}
  \item Extra: unicode: \url{http://www.joelonsoftware.com/articles/Unicode.html}
\end{itemize}

\vfill
{\Large Do:}
\begin{itemize}
    \item Finish the LABs
    \item Six more CodingBat exercises. 
    \item LPTHW: for extra practice with the concepts -- some of:\\
          excercises 5 -- 14
\end{itemize}

\end{frame}


\end{document}

 
